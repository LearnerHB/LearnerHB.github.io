<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Introduction of Kubernetes(k8s)</title>
    <link href="/2021/06/28/k8s-learning/"/>
    <url>/2021/06/28/k8s-learning/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Kubernetes-K8s-是什么"><a href="#Kubernetes-K8s-是什么" class="headerlink" title="Kubernetes(K8s)是什么"></a>Kubernetes(K8s)是什么</h2><p><a href="https://kubernetes.io/zh/">Kubernetes</a> 是用于自动部署，扩展和管理容器化应用程序的开源系统。它可以帮助用户省去应用容器化过程中的许多手动部署和扩展操作。你可以将Linux容器的多组主机聚集在一起，由Kubernetes来轻松高效地管理这些集群。<strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。</p><p>当我们把容器部署到生产环境或者扩展成多个应用，我们显然需要许多托管在相同位置的容器来协同提供各种服务，随着这些容器的积累，环境中容器的数量会急剧增加，复杂度随之增长。Kubernetes通过将容器分类成 容器集(pod)，解决了容器增殖带来的许多问题。容器集为分组容器增加了一个抽象层，可以帮助我们调用工作负载，并为这些容器提供所需的联网和存储服务，而Kubernetes的其他部分可以帮助我们在这些容器集之间达成负载均衡，同时确保运行正确数量的容器来充分支持我们的工作负载。</p><h2 id="K8s相关术语"><a href="#K8s相关术语" class="headerlink" title="K8s相关术语"></a>K8s相关术语</h2><p><strong>主机（Master）：</strong> 用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。</p><p><strong>节点（Node）：</strong>负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制。</p><p><strong>容器集（Pod）：</strong>被部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。</p><p><strong>复制控制器（Replication controller）：</strong>用于控制应在集群某处运行的完全相同的容器集副本数量。</p><p><strong>服务（Service）：</strong>将工作内容与容器集分离。Kubernetes 服务代理会自动将服务请求分发到正确的容器集——无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉。</p><p><strong>Kubelet：</strong>运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。</p><p><strong>kubectl：</strong> Kubernetes 的命令行配置工具。</p><h2 id="K8s集群架构"><a href="#K8s集群架构" class="headerlink" title="K8s集群架构"></a>K8s集群架构</h2><p>一个K8s集群可以可视化为两个部分：控制平面和计算设备（或节点）。每个节点都是自己的Linux环境，可以是物理机或者虚拟机，每个节点都运行由若干容器组成的容器集。</p><p>如下架构图显示K8s集群的各部分之间的联系。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-06-29-023053.png" alt="image-20210629103052447"></p><ul><li><p>K8s集群的神经中枢：控制平台 Control plane</p></li><li><p>K8s集群API：kube-apiserver</p></li><li><p>K8s调度程序：kube-scheduler</p></li><li><p>K8s控制器：kube-controller-manager</p></li><li><p>键值存储数据库 etcd</p></li><li><p>K8s节点：Compute machines</p><ul><li>容器集Pod</li><li>容器运行时引擎：如Docker，但K8s也支持其他诸如rkt和CRI-O</li><li>kubelet：与控制平面通信的微型应用，可确保容器在容器集内运行</li><li>kube-proxy：用于优化K8s网络服务的网络代理</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.redhat.com/zh/topics/containers/kubernetes-architecture">K8s 原理：Kubernetes 架构解析</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell杂谈</title>
    <link href="/2021/06/16/learning-shell/"/>
    <url>/2021/06/16/learning-shell/</url>
    
    <content type="html"><![CDATA[<h2 id="常用内容小记"><a href="#常用内容小记" class="headerlink" title="常用内容小记"></a>常用内容小记</h2><ul><li>echo 输出</li><li>readonly 标记只读变量</li><li>unset 删除变量</li><li>单引号<ul><li>单引号中变量无效，内部字符原样输出；</li><li>单引号字符串中不能出现单独的一个单引号，即便使用了转义字符，但可以成对出现</li></ul></li><li>双引号<ul><li>双引号里可以有变量；</li><li>双引号里可以出现转义字符</li></ul></li><li>提取子字符串：${string:1:4} 从位置1（第二个位置）开始截取4个字符</li><li>查找子字符串：<code>expr index &quot;$string&quot; io</code>  查找字符i或o的位置，哪个先出现就计算哪个</li><li>数组：<ul><li>定义 array1&#x3D;(value0 value1)   赋值 array1[0]&#x3D;value3  读取 ${array1[n]}</li><li>获取所有元素 echo ${array_name[@]}</li></ul></li><li>注释： 单行#     多行:&lt;&lt;EOF xxxx EOF  或 :&lt;&lt;’  xxxx  ‘    或 :&lt;&lt;! xxxx !</li><li>关系运算符 只支持数字或值为数字的字符串-eq -ne -gt -lt -ge -le</li><li>布尔运算符 ! -o -a</li><li>逻辑运算符 &amp;&amp; ||</li><li>字符串运算符 &#x3D; !&#x3D; -z -n $</li><li>文件测试运算符 -r file 检查file是否可读 等等……</li><li>echo 输出</li><li>显示命令执行结果，使用反引号 &#96;</li><li>单引号包括的字符串会原样输出，没有转义</li><li>printf 输出</li><li>test用于检查某个条件是否成立，可以进行 数值、字符、文件 三个方面的测试</li><li>if then elif then else 常与test结合使用</li><li>for var in item1 item2; do command1; command2; done;</li><li>Let 执行表达式 let “int++”</li><li>case esac</li><li>函数 funname(){}</li><li>函数参数<ul><li>$10不能获取第10个参数，要用${10}</li><li>$#参数个数；</li><li>$*以一个单字符串显示所有向脚本传递的参数；</li><li>$$脚本运行的当前进行ID号；</li><li>$!后台运行的最后一个进程ID号</li><li>$@与$*相同，但是使用时加引号，并在引号中返回各个参数</li><li>$-显示Shell使用的当前选项，与set命令功能相同</li><li>$? 显示最后命令的退出状态。0表示没有错误，其他值表示有错误；$?仅对上一条指令负责，一旦函数返回后没有立即保存入参数，那么其返回值将不能再通过$?获得。</li><li>输出重定向: &gt;  ; 输出以追加的方式重定向: &gt;&gt; ; 输出文件m与n合并 n &gt;&amp; m ;</li></ul></li></ul><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>一种处理文本文件的语言，强大的文本分析工具。主要用于行处理。</p><blockquote><p>grep 更适合单纯的查找或匹配文本</p><p>sed 更适合编辑匹配到的文本</p><p>awk 更适合格式化文本，对文本进行较复杂格式处理</p></blockquote><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">awk [-F filed_separator] <span class="hljs-string">&#x27;&#123;[pattern] action&#125;&#x27;</span> &#123;filenames&#125;   <span class="hljs-comment"># 行匹配语句 awk &#x27;&#x27; 只能用单引号</span><br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># log.txt文本内容如下：</span><br>1 : This is a <span class="hljs-built_in">test</span>.<br>2 : The number indicates the index of line.<br>3 : We are going to learn the basic usage of awk.<br>4 : Let<span class="hljs-string">&#x27;s list some fruits at first.</span><br><span class="hljs-string">5 : Apple, Banana, Orange &amp; Pear.</span><br><span class="hljs-string"></span><br><span class="hljs-string"># log2.txt文本内容如下：</span><br><span class="hljs-string">Apple:Banana:Potato</span><br><span class="hljs-string">Apple : Banana : Potato</span><br><span class="hljs-string">Apple: Banana: Potato</span><br><span class="hljs-string">Apple,Banana,Potato</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 每行按空格或TAB分割，输出文本中1 2 5项。参数之间用,分割的话输出会用空格分割。</span><br>$ awk <span class="hljs-string">&#x27;&#123;print $1,$2,$5&#125;&#x27;</span> log.txt<br>1 : a<br>2 : indicates<br>3 : going<br>4 : some<br>5 : Orange<br><br><span class="hljs-comment"># 格式化输出</span><br>$ awk <span class="hljs-string">&#x27;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$3&#125;&#x27;</span> log.txt <br>1        This      <br>2        The       <br>3        We        <br>4        Let<span class="hljs-string">&#x27;s     </span><br><span class="hljs-string">5        Apple,</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 指定域分隔符 -F 未加这个参数的话就是默认用空格作为分割</span><br><span class="hljs-string">$ awk -F: &#x27;</span>&#123;<span class="hljs-built_in">print</span> $1<span class="hljs-variable">$2</span>&#125;<span class="hljs-string">&#x27; log2.txt</span><br><span class="hljs-string">AppleBanana</span><br><span class="hljs-string">Apple  Banana </span><br><span class="hljs-string">Apple Banana</span><br><span class="hljs-string">Apple,Banana,Potato</span><br><span class="hljs-string">$ awk -F, &#x27;</span>&#123;<span class="hljs-built_in">print</span> $1<span class="hljs-variable">$2</span>&#125;<span class="hljs-string">&#x27; log2.txt</span><br><span class="hljs-string">Apple:Banana:Potato</span><br><span class="hljs-string">Apple : Banana : Potato</span><br><span class="hljs-string">Apple: Banana: Potato</span><br><span class="hljs-string">AppleBanana</span><br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>除了 <code>$+数字</code> 表示某个字段，awk还提供其他一些变量。常用的有NF和NR。</p><p>变量<code>NF</code>表示当前行有多少个字段，因此<code>$NF</code>就代表最后一个字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;this is a test&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $NF&#125;&#x27;</span><br><span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>变量<code>NR</code>表示当前处理的是第几行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print NR &quot;) &quot; $2&#125;&#x27;</span> log.txt<br>1)  This is a <span class="hljs-built_in">test</span>.<br>2)  The number indicates the index of line.<br>3)  We are going to learn the basic usage of awk.<br>4)  Let<span class="hljs-string">&#x27;s list some fruits at first.</span><br><span class="hljs-string">5)  Apple, Banana, Orange &amp; Pear.</span><br></code></pre></td></tr></table></figure><p>其他变量如：</p><ul><li><code>FILENAME</code>：当前文件名</li><li><code>FS</code>：字段分隔符，默认是空格和制表符。</li><li><code>RS</code>：行分隔符，用于分割每一行，默认是换行符。</li><li><code>OFS</code>：输出字段的分隔符，用于打印时分隔字段，默认为空格。</li><li><code>ORS</code>：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li><li><code>OFMT</code>：数字输出的格式，默认为<code>％.6g</code>。</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>awk 还提供了一些方便的内置函数。</p><ul><li><code>toupper()</code>：字符转为大写。</li><li><code>tolower()</code>：字符转为小写。</li><li><code>length()</code>：返回字符串长度。</li><li><code>substr()</code>：返回子字符串。</li><li><code>sin()</code>：正弦。</li><li><code>cos()</code>：余弦。</li><li><code>sqrt()</code>：平方根。</li><li><code>rand()</code>：随机数。</li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>awk允许指定输出条件，只输出符合条件的行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ awk <span class="hljs-string">&#x27;条件 动作&#x27;</span> 文件名<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;/Apple/ &#123;print $1,$2&#125;&#x27;</span> log.txt <span class="hljs-comment"># 只输出包含Apple字段的行</span><br>5   Apple, Banana, Orange &amp; Pear.<br>$ awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;NR%2==1 &#123;print $0&#125;&#x27;</span> log.txt <span class="hljs-comment"># 只输出奇数行</span><br>1 : This is a <span class="hljs-built_in">test</span>.<br>3 : We are going to learn the basic usage of awk.<br>5 : Apple, Banana, Orange &amp; Pear.<br>$ awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;$1==&quot;1 &quot; &#123;print $0&#125;&#x27;</span> log.txt<span class="hljs-comment"># 输出第一个字段等于指定值的行</span><br>1 : This is a <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>awk提供了if结构，用于编写复杂的条件。if结构还可以指定else部分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;if ($1&gt;&quot;2 &quot;) print $0; else print &quot;---&quot;&#125;&#x27;</span> log.txt<br>---<br>---<br>3 : We are going to learn the basic usage of awk.<br>4 : Let<span class="hljs-string">&#x27;s list some fruits at first.</span><br><span class="hljs-string">5 : Apple, Banana, Orange &amp; Pear.</span><br></code></pre></td></tr></table></figure><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>(Coming soon……)</p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>(Coming soon……)</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>(Coming soon……)</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>(Coming soon……)</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.gnu.org/software/gawk/manual/html_node/index.html#SEC_Contents">The GNU Awk User’s Guide</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/11/awk.html">awk入门教程-阮一峰的网络日志</a></p><p><a href="https://www.runoob.com/linux/linux-shell.html">Linux awk命令-菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Tech</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac终端改造计划</title>
    <link href="/2020/12/21/macTerminalRebuild/"/>
    <url>/2020/12/21/macTerminalRebuild/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Mac终端(Terminal)凭借Unix特性让用户爱不释手，但作为程序员们频繁使用的软件，其默认界面的文字阅读常令人感到吃力。我将借助oh-my-zsh对其进行界面上的美化，让Terminal更加美观易读。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-12-21-023914.png" alt="未改造之前的Terminal"></p><center>Figure 1. 原本的Terminal界面</center><h2 id="0-准备：安装Homebrew"><a href="#0-准备：安装Homebrew" class="headerlink" title="0. 准备：安装Homebrew"></a>0. 准备：安装Homebrew</h2><p>后续的部分插件安装需要用到homebrew，所以可以提前安装。</p><p><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p><p>如果你的macOS版本早于Catalina，你需要手动安装zsh：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装 zsh</span><br>brew install zsh<br><span class="hljs-comment"># 设置zsh为你的默认shell</span><br>chsh -s /usr/local/bin/zsh<br></code></pre></td></tr></table></figure><h2 id="1-配置Mac终端主题"><a href="#1-配置Mac终端主题" class="headerlink" title="1. 配置Mac终端主题"></a>1. 配置Mac终端主题</h2><ol><li>在 <a href="https://github.com/lysyi3m/macos-terminal-themes">OSX主题的项目主页</a> 里面选择自己喜欢的主题；</li><li>把项目Clone或者Download下来；</li><li>在 <code>themes/</code> 文件夹下，双击相应的*.terminal 文件。一个对应主题的终端窗口将会弹出；</li><li>将当前主题设置为默认：菜单里找到 <em>Shell -&gt; Use Settings as Default</em> 或 <em>Shell -&gt; 将设置用作默认设置</em> 。</li></ol><h2 id="2-安装-oh-my-zsh"><a href="#2-安装-oh-my-zsh" class="headerlink" title="2. 安装 oh-my-zsh"></a>2. 安装 oh-my-zsh</h2><p>参考 <a href="https://ohmyz.sh/">Oh My Zsh 主页</a>。Oh My Zsh 是一个令人愉快的、开源的、社区驱动的管理zsh配置的框架，安装十分简单，在Mac终端下输入如下代码即可。</p><p><code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p><h2 id="3-安装-oh-my-zsh-主题"><a href="#3-安装-oh-my-zsh-主题" class="headerlink" title="3. 安装 oh-my-zsh 主题"></a>3. 安装 oh-my-zsh 主题</h2><p>如果不想鼓捣第三方主题，oh-my-zsh内置的主题其实也完全足够。只需要：</p><ol><li>在<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">内置主题列表</a>寻找你想要的主题；</li><li>在<code>~/.zshrc</code>配置文件里设置<code>ZSH_THEME</code>为你想要的主题名称；如果你不想使用任何内置主题，也可以把这个字段设置为空：<code>ZSH_THEME=&quot;&quot;</code></li><li>激活设置<code>source ~/.zshrc</code></li></ol><p>当然，如果想要安装第三方主题，也可以在 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes">这里</a> 查看。</p><h2 id="4-安装oh-my-zsh插件"><a href="#4-安装oh-my-zsh插件" class="headerlink" title="4. 安装oh-my-zsh插件"></a>4. 安装oh-my-zsh插件</h2><p>Oh-my-zsh提供了丰富的插件，你可以通过查看Github上地 <a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins">plugins目录</a>或者 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">wiki</a>来获知哪些插件是可用的。除了许多自带的插件可以直接在~&#x2F;.zshrc 文件的 plugins字段按如下方式使用，也可以便捷地安装其他的插件。下面列举5个插件，更多地插件可以自行寻找。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># ~/.zshrc:</span><br>plugins=(<br>  git<br>  zsh-syntax-highlighting<br>)<br></code></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote><p>自带插件。可以使用缩写命令, 比如 <code>gaa</code> -&gt; <code>git add --all</code>, 通过<code>alias | grep git</code>查看所有支持缩写命令。直接按上面的方式加入plugins字段。</p></blockquote><h3 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h3><blockquote><p>自带插件。不用再使用复杂的<code>tar</code>来解压。直接按上面的方式加入plugins字段。</p></blockquote><h3 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h3><blockquote><p>自带插件。可以使用sublime text打开文件&#x2F;文件夹，用 <code>st</code> 指令直接打开sublime text (前提是已经安装)，用<code> st + 文件/文件夹</code> 可以用sublime打开指定文件夹 。直接按上面的方式加入plugins字段。</p></blockquote><h3 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h3><blockquote><p>非自带插件。使用<code>j</code>命令直接快速进入某个目录, 比如 <code>j Downloads</code> -&gt; <code>cd ~/Downloads</code>。</p></blockquote><p>用 <code>brew install autojump</code> 安装之后，按照提示在<code>~/.zshrc</code>配置文件添加:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh<br></code></pre></td></tr></table></figure><h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h3><blockquote><p>非自带插件。命令高亮，让命令五彩缤纷。</p></blockquote><p>用  <code>brew install zsh-syntax-highlighting</code> 完成安装。按照安装完成后的提示，在~&#x2F;.zshrc文件中进行相应的配置。</p><h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h3><blockquote><p>非自带插件。输入时按右方向键→自动补全命令。</p></blockquote><p>用 <code>brew install zsh-autosuggestions</code> 完成安装。按照安装完成后的提示，在~&#x2F;.zshrc文件中进行相应的配置。</p><h2 id="5-完成"><a href="#5-完成" class="headerlink" title="5. 完成"></a>5. 完成</h2><p>至此， 你应该可以拥有一个美观易用的terminal了。开始coding吧！</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-12-21-070158.png" alt="image-20201221150157035"></p><center>Figure 2. 配置之后的Terminal界面</center><h2 id="Optional-zsh安装后的conda使用：报错与解决"><a href="#Optional-zsh安装后的conda使用：报错与解决" class="headerlink" title="(Optional) zsh安装后的conda使用：报错与解决"></a>(Optional) zsh安装后的conda使用：报错与解决</h2><p>在安装完zsh，开始要使用原本环境中conda相关指令的时候出现错误，以下是错误内容和相应的解决方案。</p><ol><li><p><code>zsh：command not find:conda</code></p><ul><li><p>首先检查是否安装了conda。在anaconda安装的文件夹下的bin文件夹查看是否有conda指令，没有的话就是尚未安装。</p></li><li><p>如果已经安装了conda，但是仍然报这个错，应该是因为环境变量配置文件没有更新。对于zsh来说，配置文件是 ~&#x2F;.zshrc。</p><blockquote><p>简单来说.zshrc是linux文件夹的一个配置文件，这个文件主要保存个人的一些个性化设置，比如命名别名、路径等。</p></blockquote></li><li><p><code>vi ~/.zshrc</code> 打开配置文件。</p></li><li><p>在文件末尾加入一行<code>export PATH=/path/to/anaconda/bin:$PATH</code> 。注意这里的路径需要改成自己电脑上的anaconda的路径。比如我的电脑上装的是miniconda3，路径是 &#x2F;Users&#x2F;bing&#x2F;miniconda3&#x2F;，那么这一句就应该是<code>export PATH=/Users/bing/miniconda3/bin:$PATH</code>。添加完成后保存退出。</p></li><li><p><code>source ~/.zshrc</code> 使配置文件的修改立即生效。</p></li><li><p>再次查看conda指令，输入<code>conda --version</code>，如果可以正常显示版本号，说明问题已经解决。</p></li></ul></li><li><p><code>CommandNotFoundError: Your shell has not been properly configured to use &#39;conda activate&#39;.</code>  </p><p><strong>解决</strong>：用<code>source activate</code> 重新激活一下activate，这时候当前环境会变更到(base)，说明activate指令可以正常运行了。</p></li></ol><h2 id="Optional-zsh自定义快捷指令"><a href="#Optional-zsh自定义快捷指令" class="headerlink" title="(Optional) zsh自定义快捷指令"></a>(Optional) zsh自定义快捷指令</h2><p>平时使用terminal的时候，我们输入很长的指令往往会感到繁琐头疼。我们可以通过修改zshrc文件来设置快捷指令。</p><p>比如想要用安装的Typora软件来打开某个Markdown文件，我们需要命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">open -a &quot;Typora&quot; filename.md<br></code></pre></td></tr></table></figure><p>前摇过长，不能忍。</p><p>要实现类似 <code>st filename.md</code> 这种用Sublime Text快捷打开文件的操作，我们需要向~&#x2F;.zshrc文件添加一行<code>alias</code>指令替换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把 tp 指定为 open -a <span class="hljs-string">&quot;Typora&quot;</span>，并添加到 ~/.zshrc 文件末尾</span><br>echo &quot;alias tp=&quot;open -a &quot;Typora&quot; &quot; &quot; &gt;&gt; ~/.zshrc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行立即生效</span><br>source ~/.zshrc<br></code></pre></td></tr></table></figure><p>然后试试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tp filename.md<br></code></pre></td></tr></table></figure><p>可以发现已经可以快捷打开某文件。同理可以自行设置其他的快捷指令。:-)</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://ohmyz.sh/">Oh My Zsh - 官网</a></li><li><a href="https://github.com/ohmyzsh">Oh My Zsh - Github主页</a></li><li><a href="https://tonyxu.io/zh/posts/2018/ultimate-way-to-beautify-mac-terminal-and-recommendations-for-plugins/">程序员的Mac终端(oh-my-zsh)终极美化及必备插件推荐 | Tony Xu 博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My Spiritual Life</title>
    <link href="/2020/04/05/%E6%88%91%E7%9A%84%E7%B2%BE%E7%A5%9E%E7%94%9F%E6%B4%BB/"/>
    <url>/2020/04/05/%E6%88%91%E7%9A%84%E7%B2%BE%E7%A5%9E%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><em><strong>2020年</strong></em></p><p><strong>1月</strong></p><ul><li><p>（书）《思考，快与慢》 丹尼尔·卡尼曼</p></li><li><p>（书）《月亮与六便士》毛姆</p></li></ul><p><strong>2月</strong></p><ul><li><p>（书）《未来简史：从智人到智神》 尤瓦尔·赫拉利</p></li><li><p>（书）《邓小平时代》  傅高义</p></li><li><p>（书）《睡眠革命》尼克·利特尔黑尔斯</p></li></ul><p><strong>3月</strong></p><ul><li><p>（书）《腾讯传1998-2016》吴晓波</p></li><li><p>（书）《Python神经网络编程》塔里克·拉希德</p></li><li><p>（书）《人生的智慧》叔本华</p></li></ul><p><strong>4月</strong></p><ul><li><p>（剧）《我是余欢水》正午阳光</p></li><li><p>（书）《如果没有明天》余耕</p></li><li><p>（书）《论中国》基辛格</p></li></ul><p><strong>5月</strong></p><ul><li><p>（影）《利刃出鞘》</p></li><li><p>（书）《中国经济2020》王德培</p></li></ul><p><strong>6月</strong></p><ul><li>（影）《暗杀》</li></ul><p><strong>7月</strong></p><ul><li><p>（游）《塞尔达传说：旷野之息》</p></li><li><p>（剧）《隐秘的角落》紫金陈</p></li><li><p>（书）《剑指offer》何海涛</p></li></ul><p><strong>8月</strong></p><ul><li>（书）《原则》瑞·达利欧</li></ul><p><strong>9月</strong></p><ul><li><p>（影）《信条》诺兰</p></li><li><p>（剧）《沉默的真相》紫金陈</p></li><li><p>（漫）《雾山五行》林魂</p></li><li><p>（书）《李光耀观天下》李光耀</p></li></ul><p><strong>10月</strong></p><ul><li>（书）《贫穷的本质》阿比吉特·班纳吉 埃斯特·迪弗洛</li></ul><p><strong>11月</strong></p><ul><li><p>（影）《1917》</p></li><li><p>（剧）《The Undoing》(无所作为)</p></li></ul><p><strong>12月</strong></p><ul><li><p>（影）《绅士们》</p></li><li><p>（影）《电话》</p></li><li><p>（剧）《是，首相》</p></li><li><p>（剧）《弥留之国的爱丽丝》</p></li></ul><p><em><strong>2021年</strong></em></p><p><strong>1月</strong></p><ul><li>（影）《饥饿站台》</li></ul><p><strong>2月</strong></p><ul><li><p>DOING（书）《穷查理宝典》彼得·考夫曼</p></li><li><p>（剧）《山海情》</p></li></ul><p><strong>3月</strong></p><ul><li>DOING（书）《非暴力沟通》马歇尔·卢森堡</li></ul><p><strong>4月</strong></p><ul><li>DOING（书）《跃迁：从技术到管理的硅谷路径》朱赟</li></ul><p><strong>5月</strong></p><ul><li>繁忙的5月……</li></ul><p><strong>6月</strong></p><ul><li><p>（影）《贫民窟的百万富翁》</p></li><li><p>（剧）《爱，死亡，机器人》第二季</p></li><li><p>（剧）《九号秘事》第六季</p></li></ul><p><strong>7月</strong></p><ul><li>（书）《软技能：代码之外的生存之道》</li></ul><p><strong>8月</strong></p><ul><li><p>（剧）《扫黑风暴》</p></li><li><p>（影）《怒火：重案》</p></li><li><p>（书）《毛泽东传》罗斯·特里尔</p></li></ul><p><strong>9月</strong></p><ul><li><p>DOING（书）《禅与摩托车维修艺术》</p></li><li><p>（影）《悬崖之上》</p></li><li><p>（影）《失控玩家》</p></li><li><p>（剧）《鱿鱼游戏》</p></li></ul><p><strong>10月</strong></p><ul><li><p>（影）《长津湖》</p></li><li><p>（影）《沙丘》</p></li><li><p>（影）《八恶人》</p></li><li><p>（影）《被解救的姜戈》</p></li><li><p>DOING（书）《结构性改革》黄奇帆</p></li><li><p>DOING（书）《世界前沿技术发展报告2021》</p></li></ul><p><strong>11月</strong></p><ul><li>繁忙的11月……</li></ul><p><strong>12月</strong></p><ul><li>（书）《中国城市大洗牌》</li></ul><p><em><strong>2022年</strong></em></p><p><strong>1月</strong></p><ul><li>（书）《商业的本质与互联网》 许小年</li></ul><p><strong>2月</strong></p><ul><li><p>（书）《一看就懂的法律常识》</p></li><li><p>DOING（书）《置身事内：中国政府与经济发展》</p></li><li><p>（书）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Reading&amp;Thinking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About WeRead</title>
    <link href="/2020/03/18/aboutWeRead/"/>
    <url>/2020/03/18/aboutWeRead/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本年度至今使用体验最佳、粘性最高的应用软件：微信读书。</p><p>谈点个人的理解：用做游戏or社交软件的思路去做一个读书软件，腾讯的产品能力真的很强大。</p><p>打游戏为什么上瘾？短时间内正向激励频繁。用户粘性怎么来？刷级，装备，成就积累。微信读书有什么？记录用户看书时长，总时长以及每周时长，每周进行好友排行。在大众文化水平逐渐提高的当下，一个读书读得多、书的品质高的人，是不是会让人发自内心有所欣赏？尤其是在高知识水平用户的身上，简直一拿一个准。这其中“阅读时长”就好像是游戏里的等级，打开软件开始阅读就能刷级，也没有什么人民币玩家欺负普通玩家的剧情，对每个阅读者都是公平的，刷级的手段只有一个：阅读。用户粘性怎么积累？看了多少小时，读了多少书，全部都是可见的，这不就是游戏里的“勋章”或者“成就”吗？</p><p>如果你觉得阅读本身是一件无聊的事情，“我不喜欢读书啊，我的朋友们也都不怎么读书，那些排名什么的对我来说没有意义。腾讯哪里发展我这个用户？”。那或许你就不是腾讯的key target。读书时长排名这种手段，就是把手伸向那些对于自身所呈现的社交属性有一定高要求的用户。读书时长多≈喜欢阅读≈有耐心≈靠谱的办事能力。无需耗费口水和社交手段，直接通过静静地阅读，一边增长见识一边把个人魅力值提上去。</p><p>当其他阅读软件还在考虑用户下沉的时候，腾讯已经用丰富的产品经验，把手伸向了对社交属性有较高需求的潜在高级用户所在的市场。</p><p>腾讯把他当一个社交软件在做。你以为他在第一层，其实他在第五层。</p>]]></content>
    
    
    <categories>
      
      <category>Reading&amp;Thinking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GAN 生成对抗网络入门</title>
    <link href="/2019/08/02/GAN-Learning/"/>
    <url>/2019/08/02/GAN-Learning/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>神经网络分很多种，有普通的前向传播网络，有分析图片的CNN卷积神经网络，有分析序列化数据的RNN循环神经网络，这些都是根据数据去预测结果。而对于生成网络而言，则是”捏造结果”了。GAN(Generative Adversarial Networks，生成对抗网络)就是其中一种生成网络，是根据随机数来生成结果，提供了一种不需要大量的标注训练数据就能学习深度表征的方式。</p><p>相比于其他的生成模型，GAN有两大特点：</p><ul><li>不依赖任何的先验假设：传统的许多方法会假设数据服从某一分布，然后使用极大似然去估计数据分布。 </li><li>生成 real-like 样本的方式非常简单：通过生成器（Generator）的前向传播。</li></ul><h3 id="1-1-生成模型"><a href="#1-1-生成模型" class="headerlink" title="1.1 生成模型"></a>1.1 生成模型</h3><p><strong>生成模型</strong>是指能够随机生成观测数据的模型，尤其是在给定某些隐含参数的条件下。</p><h3 id="1-2-形象描述"><a href="#1-2-形象描述" class="headerlink" title="1.2 形象描述"></a>1.2 形象描述</h3><p>生成对抗网络的过程可以用一个新手画家和一个新手鉴赏家的例子来说明。新手画家要画一幅达芬奇的画，但是他刚开始学，不知道达芬奇的画风格要怎么呈现，于是他用新手的灵感画画，画得一团糟。这时候有一个新手鉴赏家，他接受到了一些画作，但是他不知道哪些是新手画家画的，哪些是达芬奇画的。新手鉴赏家说出了自己的判断，你来纠正他的判断。于是新手鉴赏家就一边判断，一边告诉新手画家要怎么作画才能更加接近达芬奇的画作。新手画家也就一步步学会怎么画的更像达芬奇的风格了。如下，包含一个生成网络和一个判别网络。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-04-145741.png" alt="image-20190804225740236"></p><center>图片来自 莫烦Python 的B站频道 [1]</center><h3 id="1-3-原理"><a href="#1-3-原理" class="headerlink" title="1.3 原理"></a>1.3 原理</h3><p>有两个网络，G(Generator)和D(Descriminator)。G是生成图片的网络，接收一个隐变量z（通常为服从高斯分布的随机噪声），并生成图片G(z)；D是判别网络，判定一张图片是不是真实的，输入x为一张图片，输出的D(x)代表x为真实图片的概率，输出为1表示百分百是真实图片，输出为0表示不可能为真实的图片。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-05-085445.png" alt="image-20190805165445205"></p><p>训练的过程，就是G生成尽量真实的图片去欺骗D，而D则是尽量把G生成的图片和真实的图片区分开，二者就形成了一个博弈的过程。而在最理想的情况下，博弈的最终结果，就是D完全无法区分开G的作品和真实的图片，也就是D(G(z)) &#x3D; 0.5。</p><ul><li>寻找生成模型和判别模型之间的一个纳什均衡！</li></ul><p>数学语言描述：（优化的目标函数）</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-05-031738.png" alt="image-20190805111737882"></p><ul><li><p>对判别器D来说，这是一个二分类问题。V(D,G) 为二分类问题中常见的交叉熵损失。</p></li><li><p>对于生成器 G 来说，为了尽可能欺骗 D，所以需要最大化生成样本的判别概率 D(G(z))（最小化   log(1-D(G(z)))  ）。生成器优化的目标是：最小化 V(D,G) 的最大值。</p></li><li><p>D和G采取交替训练的方法，先训练D，目标是希望V(G, D)越大越好，所以采用梯度上升；之后训练G，目标是希望V(G, D)越小越好，所以采用梯度下降</p></li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-05-033903.png" alt="image-20190805113902723"></p><ul><li>生成器G固定时，可以对V(D, G)求导，求出最佳判别器（已经被作者证明该D*(x)存在且唯一）</li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-07-083018.png" alt="image-20190807163018201"></p><ul><li>判别函数代入上面的目标函数，可以求出在最佳判别器下，生成器的目标函数等价于优化 Pdata(x) , Pg(x) 的 JS 散度 (JS-Divergence)。</li><li>全局的优化目标为Pg &#x3D; Pdata。经过若干次训练之后，如果G和D有一定的复杂度，那么二者会达到Pg &#x3D; Pdata这个均衡点，即生成器的密度概率函数等于真实数据的密度概率函数，即生成数据和密度数据一样，D(x) &#x3D; 1&#x2F;2。</li></ul><p>训练总结起来有以下步骤：</p><ol><li>参数优化过程</li></ol><p>要寻找最优的生成器，那给定一个判别器，可以将 max V(G,D) 看作训练生成器的损失函数 L(G)。设定了损失函数之后，就可以利用Adam等优化算法通过梯度下降来更新生成器G的参数。</p><ul><li>给定 G_0，最大化 V(G_0,D)，求得 D_0*，即 max[JSD(P_data(x)||P_G0(x)]；</li><li>固定 D_0*，计算θ_G1 ← θ_G0 −η(dV(G,D_0*) &#x2F;dθ_G) 以求得更新后的 G_1；</li><li>固定 G_1，最大化 V(G_1,D_0*) 以求得 D_1*，即 max[JSD(P_data(x)||P_G1(x)]；</li><li>固定 D_1*，计算θ_G2 ← θ_G1 −η(dV(G,D_0*) &#x2F;dθ_G) 以求得更新后的 G_2；</li><li>。。。</li></ul><ol start="2"><li>实际训练过程</li></ol><p>根据价值函数 V(G,D) 的定义，要求两个数学期望， E[log(D(x))] 和 E[log(1-D(G(z)))]， x 服从真实数据分布，z 服从初始化分布。实践中没法利用积分求解，所以一般是从无穷的真实数据和无穷的生成器中做采样以逼近真实的数学期望。</p><p>最大化价值函数：P_data(x) 采样 m 个样本， P_G(x) 采样 m 个样本</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-020303.png" alt="image-20190812100303119"></p><p>最小化损失函数：P_data(x) 抽取样本作为正样本，从 P_G(x) 抽取样本作为负样本，同时将逼近 -V(G,D) 的函数作为损失函数。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-020352.png" alt="image-20190812100351590"></p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-020434.png" alt="image-20190812100433912"></p><p>——用迭代和数值计算的方式实现极小极大化博弈过程。</p><ul><li><p>从真实数据分布 P_data 抽取 m 个样本</p></li><li><p>从先验分布 P_prior(z) 抽取 m 个噪声样本</p></li><li><p>将噪声样本投入 G 而生成数据，通过最大化 V 的近似而更新判别器参数θ_d，即极大化，判别器参数的更新迭代式：<img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-022447.png" alt="image-20190812102447202"></p><p>—— 以上是学习判别器D的过程。学习D的过程是计算JS散度的过程，我们希望最大化价值函数，所以会进行K次迭代。实践中好像一般K取1也足够。</p></li><li><p>从先验分布 P_prior(z) 中抽取另外 m 个噪声样本 {z^1,…,z^m}</p></li><li><p>生成器参数的更新迭代式：<img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-022556.png" alt="image-20190812102556437"></p><p>——以上是学习生成器G的过程。为避免更新太多使得JS散度上升，在一次迭代中只进行一次。</p></li></ul><h3 id="1-4-优缺点"><a href="#1-4-优缺点" class="headerlink" title="1.4 优缺点"></a>1.4 优缺点</h3><p>优点：无需马尔可夫链，仅仅使用反向传播来获得梯度，学习间无需推理，且模型中可以融合入多种函数。</p><p>缺点：需要同步D和G；p(x)的隐式表示（？？？不太懂）</p><ul><li>生成对抗网络模型和其他生成模型之间的对比：</li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-054441.png" alt="image-20190812134440513"></p><h2 id="2-其他常见生成式模型"><a href="#2-其他常见生成式模型" class="headerlink" title="2. 其他常见生成式模型"></a>2. 其他常见生成式模型</h2><h3 id="2-1-PixelCNN-和-PixelRNN"><a href="#2-1-PixelCNN-和-PixelRNN" class="headerlink" title="2.1 PixelCNN 和 PixelRNN"></a>2.1 PixelCNN 和 PixelRNN</h3><p>对图像数据的概率分布Pdata(x)进行显式建模，并利用极大似然估计优化模型。给定 x1,x2,…,xi-1 条件下，所有 p(xi) 的概率乘起来就是图像数据的分布。如果使用 RNN 对上述依然关系建模，就是 pixelRNN。如果使用 CNN，则是 pixelCNN。</p><p>优点：定义了一个易于处理的密度函数，可以直接优化训练数据的似然。</p><p>缺点：像素值是从图像的一个角落开始，一个个生成的，所以速度会很慢。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-11-155649.png" alt="image-20190811235648428"></p><h3 id="2-2-VAE-Variational-Auto-Encode-变分自编码器"><a href="#2-2-VAE-Variational-Auto-Encode-变分自编码器" class="headerlink" title="2.2 VAE: Variational Auto-Encode 变分自编码器"></a>2.2 VAE: Variational Auto-Encode 变分自编码器</h3><p>真实样本X通过神经网络计算出均值方差，假设隐变量服从正态分布。然后通过采样得到采样变量Z进行重构。VAE和GAN均学习了隐变量 z 到真实数据分布的映射，但VAE的不同之处在于：</p><ul><li>GAN思路直接，使用一个判别器去度量分布转换模块（即生成器）生成分布与真实数据分布的距离。</li><li>VAE委婉，通过约束隐变量 z 服从标准正态分布以及重构数据实现了分布转换映射 X&#x3D;G(z)。</li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-11-154857.png" alt="image-20190811234857262"></p><h2 id="3-GAN常见模型结构"><a href="#3-GAN常见模型结构" class="headerlink" title="3. GAN常见模型结构"></a>3. GAN常见模型结构</h2><h3 id="3-1-DCGAN"><a href="#3-1-DCGAN" class="headerlink" title="3.1 DCGAN"></a>3.1 DCGAN</h3><p>提出使用CNN结构来稳定GAN的训练，这允许了生成器和判别器学习优秀的上采样和下采样操作，这些操作可能提升图像合成的质量。</p><h3 id="3-2-层级结构"><a href="#3-2-层级结构" class="headerlink" title="3.2 层级结构"></a>3.2 层级结构</h3><p>GAN 对于高分辨率图像生成一直存在许多问题，层级结构的 GAN 通过逐层次，分阶段生成，一步步提生图像的分辨率。</p><ul><li>使用多对GAN：StackGAN、GoGAN</li><li>单一GAN，多阶段生成：ProgressiveGAN</li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-11-161613.png" alt="image-20190812001612728"></p><h3 id="3-3-自编码结构"><a href="#3-3-自编码结构" class="headerlink" title="3.3 自编码结构"></a>3.3 自编码结构</h3><p>BEGAN，EBGAN，MAGAN ……</p><h2 id="4-GAN存在的问题"><a href="#4-GAN存在的问题" class="headerlink" title="4. GAN存在的问题"></a>4. GAN存在的问题</h2><ul><li><p>不收敛问题：由于GAN是采用极小极大博弈，D 在进行梯度下降时，使得在损失流形上下降，而G使其上升，可能造成两者的梯度相互抵消，最终在最优点附近徘徊。因此，不收敛问题也是GAN所面临的最大的问题。目前采用的优化方法都是采用的启发式的方法。WGAN也在一定程度上解决了收敛不稳定的问题。</p></li><li><p>模式崩溃：生成器”崩溃”，即用不同的输入生成相似的样本。可以理解成多样性问题，当G生成了一张比较真实的图片之后，就不再学习其他的分布，而仅靠这一张图片来欺骗，仅仅收敛到一种模式。这样即便训练时间再长也不会有好的结果。</p></li><li><p>梯度消失：判别器的损失很快收敛为零，从而没有足够强的梯度路径可以继续更新生成器</p></li><li><p>离散输出问题：GAN对生成器的唯一要求就是——生成器表示的函数必须可导，因此，GAN似乎无法用于离散输出，如文本。目前，仍未有将GAN应用于NLP领域。目前可能解决该问题三个可能的方向：采用强化学习、采用具体的分布、训练生成器产生连续的输出值，并将其编码为离散值。</p></li></ul><h2 id="5-GAN的发展"><a href="#5-GAN的发展" class="headerlink" title="5. GAN的发展"></a>5. GAN的发展</h2><h3 id="5-1-GAN-Generative-Adversarial-Networks，-2014"><a href="#5-1-GAN-Generative-Adversarial-Networks，-2014" class="headerlink" title="5.1 GAN: Generative Adversarial Networks， 2014"></a>5.1 GAN: Generative Adversarial Networks， 2014</h3><p>论文地址: <a href="https://link.juejin.im/?target=https://arxiv.org/abs/1406.2661">arxiv.org&#x2F;abs&#x2F;1406.26…</a></p><p>“GAN之父” Ian Goodfellow 发表的第一篇提出 GAN 的论文，提出了 GAN 这个模型框架，讨论了非饱和的损失函数，然后对于最佳判别器(optimal discriminator)给出其导数，然后进行证明；最后是在 Mnist、TFD、CIFAR-10 数据集上进行了实验。</p><p>结论和未来的研究方向：</p><ul><li>条件生成模型p(x∣c)可以通过将c作为G和D的输入来获得。</li><li>半监督学习：提供适量的带标签数据，以提高判别网络或推理网络的特征分类效果。</li><li>效率改善：设计更好的方法来协调D和G，或确定更好的分布来对 z 进行采样，以提高训练速率。</li><li>……</li></ul><h3 id="5-2-Conditional-GAN，-2014"><a href="#5-2-Conditional-GAN，-2014" class="headerlink" title="5.2 Conditional GAN， 2014"></a>5.2 Conditional GAN， 2014</h3><p>论文地址：<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1411.1784">arxiv.org&#x2F;abs&#x2F;1411.17…</a></p><p>之前的GAN是无监督模型，但给生成器提供随机噪声的话效果往往没有那么好。cGAN的提出将其拉回监督学习领域，缓和了GAN的训练不稳定的问题。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-024751.png" alt="image-20190812104750739"></p><h3 id="5-3-DCGAN"><a href="#5-3-DCGAN" class="headerlink" title="5.3 DCGAN"></a>5.3 DCGAN</h3><p> Deep Convolutional GAN </p><p>第一次采用CNN结构实现GAN。将G和D换成两个CNN，但对CNN的结构做出了一些改变来提高样本质量和收敛速度：</p><ul><li>取消池化层，G网络中使用转置卷积层（transposed convolutional layer）进行上采样，D网络中用加入stride的卷积代替pooling。</li><li>D和G中均使用batch normalization（？？？）</li><li>去掉全连接层，使网络变为全卷积网络</li><li>G网络中使用ReLU作为激活函数，最后一层使用tanh</li><li>D网络中使用LeakyReLU作为激活函数</li><li>采用Adam优化算法，学习率是0.0002，beta1&#x3D;0.5</li></ul><p>DCGAN中的G网络：</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-12-062835.png" alt="image-20190812142834368"></p><p>这篇论文介绍了如何使用卷积层，并给出一些额外的结构上的指导建议来实现。另外，它还讨论如何可视化 GAN 的特征、隐空间的插值、利用判别器特征训练分类器以及评估结果。</p><h3 id="5-4-Improved-Techniques-for-Training-GANs"><a href="#5-4-Improved-Techniques-for-Training-GANs" class="headerlink" title="5.4 Improved Techniques for Training GANs"></a>5.4 Improved Techniques for Training GANs</h3><p>论文地址：<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1606.03498">arxiv.org&#x2F;abs&#x2F;1606.03…</a></p><p>作者之一是 Ian Goodfellow。论文介绍了很多如何构建一个 GAN 结构的建议，可以帮助理解 GAN 不稳定的原因，给出稳定训练 DCGANs 的建议，比如特征匹配(feature matching)、最小批次判别(minibatch discrimination)、单边标签平滑(one-sided label smoothing)、虚拟批归一化(virtual batch normalization)等等。</p><h3 id="5-5-Pix2Pix"><a href="#5-5-Pix2Pix" class="headerlink" title="5.5 Pix2Pix"></a>5.5 Pix2Pix</h3><p>Image-to-Image Translation with Conditional Adversarial Networks</p><p>论文地址：<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1611.07004">arxiv.org&#x2F;abs&#x2F;1611.07…</a></p><p>目标是实现图像转换：语义图转街景，黑白图片上色，素描图变真实照片等。</p><p>在训练时候需要采用成对的训练数据，并对 GAN 模型采用了不同的配置。其中它应用到了 PatchGAN 这个模型，PatchGAN 对图片的一块 70*70 大小的区域进行观察来判断该图片是真是假，而不需要观察整张图片。生成器部分使用 U-Net 结构，即结合了 ResNet 网络中的 skip connections 技术，编码器和解码器对应层之间有相互连接。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-015316.png" alt="image-20190813095316532"></p><h3 id="5-6-CycleGAN"><a href="#5-6-CycleGAN" class="headerlink" title="5.6 CycleGAN"></a>5.6 CycleGAN</h3><p>Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks</p><p>论文地址：<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1703.10593">arxiv.org&#x2F;abs&#x2F;1703.10…</a></p><p>和上面的Pix2Pix不同，不需要原图和转换后的图来训练，仅仅需要准备两个领域的数据集即可，比如说普通马的图片和斑马的图片，但不需要一一对应。这篇论文提出了一个非常好的方法–循环一致性(Cycle-Consistency)损失函数。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-015734.png" alt="image-20190813095734307"></p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-015719.png" alt="image-20190813095719444"></p><h3 id="5-7-Progressive-Growing-of-GANs"><a href="#5-7-Progressive-Growing-of-GANs" class="headerlink" title="5.7 Progressive Growing of GANs"></a>5.7 Progressive Growing of GANs</h3><p>Progressive Growing of GANs for Improved Quality, Stability, and Variation</p><p>论文地址：<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1710.10196">arxiv.org&#x2F;abs&#x2F;1710.10…</a></p><p>利用一个多尺度结构，从 <code>4*4</code> 到 <code>8*8</code> 一直提升到 <code>1024*1024</code> 的分辨率，如下图所示的结构，这篇论文提出了一些如何解决由于目标图片尺寸导致的不稳定问题。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-020009.png" alt="image-20190813100008687"></p><h3 id="5-8-StackGAN"><a href="#5-8-StackGAN" class="headerlink" title="5.8 StackGAN"></a>5.8 StackGAN</h3><p>StackGAN: Text to Photo-realistic Image Synthesis with Stacked Generative Adversarial Networks</p><p>论文地址：<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1612.03242">arxiv.org&#x2F;abs&#x2F;1612.03…</a></p><p>StackGAN 和 cGAN、Progressively GANs 两篇论文比较相似，它同样采用了先验知识，以及多尺度方法。整个网络结构如下图所示，第一阶段根据给定文本描述和随机噪声，然后输出 <code>64*64</code>的图片，接着将其作为先验知识，再次生成 <code>256*256</code>大小的图片。相比前面 7 篇论文，StackGAN 通过一个文本向量来引入文本信息，并提取一些视觉特征。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-020146.png" alt="image-20190813100146022"></p><h3 id="5-9-BigGAN"><a href="#5-9-BigGAN" class="headerlink" title="5.9 BigGAN"></a>5.9 BigGAN</h3><p>Large Scale GAN Training for High Fidelity Natural Image Synthesis</p><p>论文地址：<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1809.11096">arxiv.org&#x2F;abs&#x2F;1809.11…</a></p><p>当前 ImageNet 上图片生成最好的模型，但这篇论文比较难在本地电脑上进行复现。它同时结合了很多结构和技术，包括自注意机制(Self-Attention)、谱归一化(Spectral Normalization)等。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-020411.png" alt="image-20190813100410787"></p><h2 id="6-GAN的实现"><a href="#6-GAN的实现" class="headerlink" title="6. GAN的实现"></a>6. GAN的实现</h2><h3 id="6-1-MNIST数据集上的应用"><a href="#6-1-MNIST数据集上的应用" class="headerlink" title="6.1 MNIST数据集上的应用"></a>6.1 MNIST数据集上的应用</h3><ul><li>进行GAN实验时候，只是将二维的数据拉伸成一维，没有用到卷积，只是多层神经网络的叠加。</li><li>生成器和判别器使用不同的激活函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span>...<br><span class="hljs-keyword">from</span> skimage.io <span class="hljs-keyword">import</span> imsave     <span class="hljs-comment">#保存影像</span><br><span class="hljs-comment">#from tensorflow.examples.tutorials.mnist import input_data  #第一次下载数据时解注释</span><br><span class="hljs-comment">#data = input_data.read_data_sets(&#x27;MNIST_data/&#x27;)             #第一次下载数据时解注释</span><br> <br><span class="hljs-comment">#设置超参数</span><br>image_height = ...<br>...<br> <br><span class="hljs-comment">#定义load_data()函数以读取数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">data_path</span>):...<br> <br><span class="hljs-comment">#定义GAN的生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator</span>(<span class="hljs-params">z_prior</span>):...<br> <br><span class="hljs-comment">#定义GAN的判别器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">discriminator</span>(<span class="hljs-params">x_data, x_generated, keep_prob</span>):...<br> <br><span class="hljs-comment">#显示结果的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_result</span>(<span class="hljs-params">batch_res, fname, grid_size=(<span class="hljs-params"><span class="hljs-number">8</span>, <span class="hljs-number">8</span></span>), grid_pad=<span class="hljs-number">5</span></span>):...<br> <br><span class="hljs-comment">#定义训练过程</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>():...<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> train:<br>        train()<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#mnist数据集下载，下载之后的文件在MNIST_data文件夹下</span><br><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<br>data = input_data.read_data_sets(<span class="hljs-string">&#x27;MNIST_data/&#x27;</span>, one_hot = <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 定义load_data()函数以读取数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">data_path</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    函数功能：导出MNIST数据</span><br><span class="hljs-string">    输入: data_path   传入数据所在路径（解压后的数据）</span><br><span class="hljs-string">    输出: train_data  输出data，形状为(60000, 28, 28, 1)    </span><br><span class="hljs-string">         train_label  输出label，形状为(60000, 1)                 </span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    f_data = <span class="hljs-built_in">open</span>(os.path.join(data_path, <span class="hljs-string">&#x27;train-images.idx3-ubyte&#x27;</span>))<br>    loaded_data = np.fromfile(file=f_data, dtype=np.uint8)<br>    <span class="hljs-comment">#前16个字符为说明符，需要跳过</span><br>    train_data = loaded_data[<span class="hljs-number">16</span>:].reshape((-<span class="hljs-number">1</span>, <span class="hljs-number">784</span>)).astype(np.<span class="hljs-built_in">float</span>)<br> <br>    f_label = <span class="hljs-built_in">open</span>(os.path.join(data_path, <span class="hljs-string">&#x27;train-labels.idx1-ubyte&#x27;</span>))<br>    loaded_label = np.fromfile(file=f_label, dtype=np.uint8)<br>    <span class="hljs-comment">#前8个字符为说明符，需要跳过</span><br>    train_label = loaded_label[<span class="hljs-number">8</span>:].reshape((-<span class="hljs-number">1</span>)).astype(np.<span class="hljs-built_in">float</span>)<br> <br>    <span class="hljs-keyword">return</span> train_data, train_label<br><br><br><span class="hljs-comment"># 导入需要的包</span><br><span class="hljs-keyword">import</span> os                         <span class="hljs-comment">#读取路径下文件</span><br><span class="hljs-keyword">import</span> shutil                     <span class="hljs-comment">#递归删除文件</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf           <span class="hljs-comment">#编写神经网络</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np                <span class="hljs-comment">#矩阵运算操作</span><br><span class="hljs-keyword">from</span> skimage.io <span class="hljs-keyword">import</span> imsave     <span class="hljs-comment">#保存影像</span><br><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data  <span class="hljs-comment">#第一次下载数据时用</span><br> <br><span class="hljs-comment"># 图像的size为(28, 28, 1)</span><br>image_height = <span class="hljs-number">28</span>           <br>image_width = <span class="hljs-number">28</span><br>image_size = image_height * image_width<br> <br><span class="hljs-comment"># 是否训练和存储设置</span><br>train = <span class="hljs-literal">True</span><br>restore = <span class="hljs-literal">False</span>              <span class="hljs-comment">#是否存储训练结果</span><br>output_path = <span class="hljs-string">&quot;./output/&quot;</span>    <span class="hljs-comment">#存储文件的路径</span><br> <br><span class="hljs-comment"># 实验所需的超参数</span><br>max_epoch = <span class="hljs-number">500</span><br>batch_size = <span class="hljs-number">256</span><br>h1_size = <span class="hljs-number">256</span>         <span class="hljs-comment">#第一隐藏层的size，即特征数</span><br>h2_size = <span class="hljs-number">512</span>         <span class="hljs-comment">#第二隐藏层的size，即特征数</span><br>z_size = <span class="hljs-number">128</span>          <span class="hljs-comment">#生成器的传入参数</span><br><br><br><span class="hljs-comment"># 定义GAN的生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator</span>(<span class="hljs-params">z_prior</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    函数功能：生成影像，参与训练过程</span><br><span class="hljs-string">    输入：z_prior,       #输入tf格式，size为（batch_size, z_size）的数据</span><br><span class="hljs-string">    输出：x_generate,    #生成图像</span><br><span class="hljs-string">         g_params,      #生成图像的所有参数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 第一个链接层 </span><br>    <span class="hljs-comment">#以2倍标准差stddev的截断的正态分布中生成大小为[z_size, h1_size]的随机值，权值weight初始化。</span><br>    w1 = tf.Variable(tf.truncated_normal([z_size, h1_size], stddev=<span class="hljs-number">0.1</span>), name=<span class="hljs-string">&quot;g_w1&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#生成大小为[h1_size]的0值矩阵，偏置bias初始化</span><br>    b1 = tf.Variable(tf.zeros([h1_size]), name=<span class="hljs-string">&quot;g_b1&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#通过矩阵运算，将输入z_prior传入隐含层h1。激活函数为relu</span><br>    h1 = tf.nn.relu(tf.matmul(z_prior, w1) + b1)<br> <br>    <span class="hljs-comment"># 第二个链接层 </span><br>    <span class="hljs-comment">#以2倍标准差stddev的截断的正态分布中生成大小为[h1_size, h2_size]的随机值，权值weight初始化。</span><br>    w2 = tf.Variable(tf.truncated_normal([h1_size, h2_size], stddev=<span class="hljs-number">0.1</span>), name=<span class="hljs-string">&quot;g_w2&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#生成大小为[h2_size]的0值矩阵，偏置bias初始化</span><br>    b2 = tf.Variable(tf.zeros([h2_size]), name=<span class="hljs-string">&quot;g_b2&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#通过矩阵运算，将h1传入隐含层h2。激活函数为relu</span><br>    h2 = tf.nn.relu(tf.matmul(h1, w2) + b2)<br> <br>    <span class="hljs-comment"># 第三个链接层 </span><br>    <span class="hljs-comment">#以2倍标准差stddev的截断的正态分布中生成大小为[h2_size, image_size]的随机值，权值weight初始化。</span><br>    w3 = tf.Variable(tf.truncated_normal([h2_size, image_size], stddev=<span class="hljs-number">0.1</span>), name=<span class="hljs-string">&quot;g_w3&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#生成大小为[image_size]的0值矩阵，偏置bias初始化</span><br>    b3 = tf.Variable(tf.zeros([image_size]), name=<span class="hljs-string">&quot;g_b3&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#通过矩阵运算，将h2传入隐含层h3。</span><br>    h3 = tf.matmul(h2, w3) + b3<br>    <span class="hljs-comment">#利用tanh激活函数，将h3传入输出层</span><br>    x_generate = tf.nn.tanh(h3)<br> <br>    <span class="hljs-comment">#将所有参数合并到一起</span><br>    g_params = [w1, b1, w2, b2, w3, b3]<br> <br>    <span class="hljs-keyword">return</span> x_generate, g_params<br><br><span class="hljs-comment"># 定义GAN的判别器 </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">discriminator</span>(<span class="hljs-params">x_data, x_generated, keep_prob</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    函数功能：对输入数据进行判断，并保存其参数</span><br><span class="hljs-string">    输入：x_data,        #输入的真实数据 </span><br><span class="hljs-string">        x_generated,     #生成器生成的虚假数据</span><br><span class="hljs-string">        keep_prob，      #dropout率，防止过拟合</span><br><span class="hljs-string">    输出：y_data,        #判别器对batch个数据的处理结果</span><br><span class="hljs-string">        y_generated,     #判别器对余下数据的处理结果</span><br><span class="hljs-string">        d_params，       #判别器的参数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 合并输入数据，包括真实数据x_data和生成器生成的假数据x_generated</span><br>    x_in = tf.concat([x_data, x_generated], <span class="hljs-number">0</span>) <br> <br>    <span class="hljs-comment"># 第一个链接层</span><br>    <span class="hljs-comment">#以2倍标准差stddev的截断的正态分布中生成大小为[image_size, h2_size]的随机值，权值weight初始化。</span><br>    w1 = tf.Variable(tf.truncated_normal([image_size, h2_size], stddev=<span class="hljs-number">0.1</span>), name=<span class="hljs-string">&quot;d_w1&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#生成大小为[h2_size]的0值矩阵，偏置bias初始化</span><br>    b1 = tf.Variable(tf.zeros([h2_size]), name=<span class="hljs-string">&quot;d_b1&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#通过矩阵运算，将输入x_in传入隐含层h1.同时以一定的dropout率舍弃节点，防止过拟合</span><br>    h1 = tf.nn.dropout(tf.nn.relu(tf.matmul(x_in, w1) + b1), keep_prob)<br> <br>    <span class="hljs-comment"># 第二个链接层</span><br>    <span class="hljs-comment">#以2倍标准差stddev的截断的正态分布中生成大小为[h2_size, h1_size]的随机值，权值weight初始化。</span><br>    w2 = tf.Variable(tf.truncated_normal([h2_size, h1_size], stddev=<span class="hljs-number">0.1</span>), name=<span class="hljs-string">&quot;d_w2&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#生成大小为[h1_size]的0值矩阵，偏置bias初始化</span><br>    b2 = tf.Variable(tf.zeros([h1_size]), name=<span class="hljs-string">&quot;d_b2&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#通过矩阵运算，将h1传入隐含层h2.同时以一定的dropout率舍弃节点，防止过拟合</span><br>    h2 = tf.nn.dropout(tf.nn.relu(tf.matmul(h1, w2) + b2), keep_prob)<br> <br>    <span class="hljs-comment"># 第三个链接层</span><br>    <span class="hljs-comment">#以2倍标准差stddev的截断的正态分布中生成大小为[h1_size, 1]的随机值，权值weight初始化。</span><br>    w3 = tf.Variable(tf.truncated_normal([h1_size, <span class="hljs-number">1</span>], stddev=<span class="hljs-number">0.1</span>), name=<span class="hljs-string">&quot;d_w3&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#生成0值，偏置bias初始化</span><br>    b3 = tf.Variable(tf.zeros([<span class="hljs-number">1</span>]), name=<span class="hljs-string">&quot;d_b3&quot;</span>, dtype=tf.float32)<br>    <span class="hljs-comment">#通过矩阵运算，将h2传入隐含层h3</span><br>    h3 = tf.matmul(h2, w3) + b3<br>    <br>    <span class="hljs-comment">#从h3中切出batch_size张图像</span><br>    y_data = tf.nn.sigmoid(tf.<span class="hljs-built_in">slice</span>(h3, [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [batch_size, -<span class="hljs-number">1</span>], name=<span class="hljs-literal">None</span>))<br>    <span class="hljs-comment">#从h3中切除余下的图像</span><br>    y_generated = tf.nn.sigmoid(tf.<span class="hljs-built_in">slice</span>(h3, [batch_size, <span class="hljs-number">0</span>], [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], name=<span class="hljs-literal">None</span>))<br> <br>    <span class="hljs-comment">#判别器的所有参数</span><br>    d_params = [w1, b1, w2, b2, w3, b3]<br> <br>    <span class="hljs-keyword">return</span> y_data, y_generated, d_params<br><br><span class="hljs-comment">#显示结果的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_result</span>(<span class="hljs-params">batch_res, fname, grid_size=(<span class="hljs-params"><span class="hljs-number">8</span>, <span class="hljs-number">8</span></span>), grid_pad=<span class="hljs-number">5</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    函数功能：输入相关参数，将运行结果以图片的形式保存到当前路径下</span><br><span class="hljs-string">    输入：batch_res,       #输入数据</span><br><span class="hljs-string">        fname,             #输入路径</span><br><span class="hljs-string">        grid_size=(8, 8),  #默认输出图像为8*8张</span><br><span class="hljs-string">        grid_pad=5，       #默认图像的边缘留白为5像素</span><br><span class="hljs-string">    输出：无</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#将batch_res进行值[0, 1]归一化，同时将其reshape成（batch_size, image_height, image_width）</span><br>    batch_res = <span class="hljs-number">0.5</span> * batch_res.reshape((batch_res.shape[<span class="hljs-number">0</span>], image_height, image_width)) + <span class="hljs-number">0.5</span><br>    <span class="hljs-comment">#重构显示图像格网的参数</span><br>    img_h, img_w = batch_res.shape[<span class="hljs-number">1</span>], batch_res.shape[<span class="hljs-number">2</span>]<br>    grid_h = img_h * grid_size[<span class="hljs-number">0</span>] + grid_pad * (grid_size[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>)<br>    grid_w = img_w * grid_size[<span class="hljs-number">1</span>] + grid_pad * (grid_size[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)<br>    img_grid = np.zeros((grid_h, grid_w), dtype=np.uint8)<br>    <span class="hljs-keyword">for</span> i, res <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(batch_res):<br>        <span class="hljs-keyword">if</span> i &gt;= grid_size[<span class="hljs-number">0</span>] * grid_size[<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">break</span><br>        img = (res) * <span class="hljs-number">255.</span><br>        img = img.astype(np.uint8)<br>        row = (i // grid_size[<span class="hljs-number">0</span>]) * (img_h + grid_pad)<br>        col = (i % grid_size[<span class="hljs-number">1</span>]) * (img_w + grid_pad)<br>        img_grid[row:row + img_h, col:col + img_w] = img<br>    <span class="hljs-comment">#保存图像</span><br>    imsave(fname, img_grid)<br><br><br><span class="hljs-comment"># 定义训练过程</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    函数功能：训练整个GAN网络，并随机生成手写数字</span><br><span class="hljs-string">    输入：无</span><br><span class="hljs-string">    输出：sess.saver()</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 加载数据</span><br>    train_data, train_label = load_data(<span class="hljs-string">&quot;MNIST_data&quot;</span>)<br>    size = train_data.shape[<span class="hljs-number">0</span>]<br> <br>    <span class="hljs-comment"># 构建模型---------------------------------------------------------------------</span><br>    <span class="hljs-comment"># 定义GAN网络的输入，其中x_data为[batch_size, image_size], z_prior为[batch_size, z_size]</span><br>    x_data = tf.placeholder(tf.float32, [batch_size, image_size], name=<span class="hljs-string">&quot;x_data&quot;</span>) <span class="hljs-comment"># (batch_size, image_size)</span><br>    z_prior = tf.placeholder(tf.float32, [batch_size, z_size], name=<span class="hljs-string">&quot;z_prior&quot;</span>) <span class="hljs-comment"># (batch_size, z_size)</span><br>    <span class="hljs-comment"># 定义dropout率</span><br>    keep_prob = tf.placeholder(tf.float32, name=<span class="hljs-string">&quot;keep_prob&quot;</span>) <br>    rate = <span class="hljs-number">1</span> - keep_prob<br>    global_step = tf.Variable(<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;global_step&quot;</span>, trainable=<span class="hljs-literal">False</span>)<br> <br>    <span class="hljs-comment"># 利用生成器生成数据x_generated和参数g_params</span><br>    x_generated, g_params = generator(z_prior)<br>    <span class="hljs-comment"># 利用判别器判别生成器的结果</span><br>    y_data, y_generated, d_params = discriminator(x_data, x_generated, rate)<br> <br>    <span class="hljs-comment"># 定义判别器和生成器的loss函数</span><br>    d_loss = - (tf.log(y_data) + tf.log(<span class="hljs-number">1</span> - y_generated))<br>    g_loss = - tf.log(y_generated)<br> <br>    <span class="hljs-comment"># 设置学习率为0.0001，用AdamOptimizer进行优化</span><br>    optimizer = tf.train.AdamOptimizer(<span class="hljs-number">0.0001</span>)<br> <br>    <span class="hljs-comment"># 判别器discriminator 和生成器 generator 对损失函数进行最小化处理</span><br>    d_trainer = optimizer.minimize(d_loss, var_list=d_params)<br>    g_trainer = optimizer.minimize(g_loss, var_list=g_params)<br>    <span class="hljs-comment"># 模型构建完毕--------------------------------------------------------------------</span><br> <br>    <span class="hljs-comment"># 全局变量初始化</span><br>    init = tf.global_variables_initializer()<br> <br>    <span class="hljs-comment"># 启动会话sess</span><br>    saver = tf.train.Saver()<br>    sess = tf.Session()<br>    sess.run(init)<br> <br>    <span class="hljs-comment"># 判断是否需要存储</span><br>    <span class="hljs-keyword">if</span> restore:<br>        <span class="hljs-comment">#若是，将最近一次的checkpoint点存到outpath下</span><br>        chkpt_fname = tf.train.latest_checkpoint(output_path)<br>        saver.restore(sess, chkpt_fname)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment">#若否，判断目录是存在，如果目录存在，则递归的删除目录下的所有内容，并重新建立目录</span><br>        <span class="hljs-keyword">if</span> os.path.exists(output_path):<br>            shutil.rmtree(output_path)<br>        os.mkdir(output_path)<br> <br>    <span class="hljs-comment"># 利用随机正态分布产生噪声影像，尺寸为(batch_size, z_size)</span><br>    z_sample_val = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, size=(batch_size, z_size)).astype(np.float32)<br> <br>    <span class="hljs-comment"># 逐个epoch内训练</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sess.run(global_step), max_epoch):<br>        <span class="hljs-comment"># 图像每个epoch内可以放(size // batch_size)个size</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size // batch_size):<br>            <span class="hljs-keyword">if</span> j%<span class="hljs-number">20</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;epoch:%s, iter:%s&quot;</span> % (i, j))<br>            <br>            <span class="hljs-comment"># 训练一个batch的数据</span><br>            batch_end = j * batch_size + batch_size<br>            <span class="hljs-keyword">if</span> batch_end &gt;= size:<br>                batch_end = size - <span class="hljs-number">1</span><br>            x_value = train_data[ j * batch_size : batch_end ]<br>            <span class="hljs-comment"># 将数据归一化到[-1, 1]</span><br>            x_value = x_value / <span class="hljs-number">255.</span><br>            x_value = <span class="hljs-number">2</span> * x_value - <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 以正太分布的形式产生随机噪声</span><br>            z_value = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, size=(batch_size, z_size)).astype(np.float32)<br>            <span class="hljs-comment"># 每个batch下，输入数据运行GAN，训练判别器</span><br>            sess.run(d_trainer,<br>                     feed_dict=&#123;x_data: x_value, z_prior: z_value, rate: np.<span class="hljs-built_in">sum</span>(<span class="hljs-number">0.7</span>).astype(np.float32)&#125;)<br>            <span class="hljs-comment"># 每个batch下，输入数据运行GAN，训练生成器</span><br>            <span class="hljs-keyword">if</span> j % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<br>                sess.run(g_trainer,<br>                         feed_dict=&#123;x_data: x_value, z_prior: z_value, rate: np.<span class="hljs-built_in">sum</span>(<span class="hljs-number">0.7</span>).astype(np.float32)&#125;)<br>        <span class="hljs-comment"># 每一个epoch中的所有batch训练完后，利用z_sample测试训练后的生成器</span><br>        x_gen_val = sess.run(x_generated, feed_dict=&#123;z_prior: z_sample_val&#125;)<br>        <span class="hljs-comment"># 每一个epoch中的所有batch训练完后，显示生成器的结果，并打印生成结果的值</span><br>        show_result(x_gen_val, os.path.join(output_path, <span class="hljs-string">&quot;sample%s.jpg&quot;</span> % i))<br>        <span class="hljs-built_in">print</span>(x_gen_val)<br>        <span class="hljs-comment"># 每一个epoch中，生成随机分布以重置z_random_sample_val</span><br>        z_random_sample_val = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, size=(batch_size, z_size)).astype(np.float32)<br>        <span class="hljs-comment"># 每一个epoch中，利用z_random_sample_val生成手写数字图像，并显示结果</span><br>        x_gen_val = sess.run(x_generated, feed_dict=&#123;z_prior: z_random_sample_val&#125;)<br>        show_result(x_gen_val, os.path.join(output_path, <span class="hljs-string">&quot;random_sample%s.jpg&quot;</span> % i))<br>        <span class="hljs-comment"># 保存会话</span><br>        sess.run(tf.assign(global_step, i + <span class="hljs-number">1</span>))<br>        saver.save(sess, os.path.join(output_path, <span class="hljs-string">&quot;model&quot;</span>), global_step=global_step)<br><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> train:<br>        train()<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>Epoch 1: <img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-012847.png" alt="image-20190813092847343"></p><p>Epoch 10:<img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-013022.png" alt="image-20190813093021600"></p><p>Epoch 50:<img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-013053.png" alt="image-20190813093052998"></p><p>Epoch 100:<img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-013115.png" alt="image-20190813093115056"></p><p>Epoch 300:<img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-013131.png" alt="image-20190813093130880"></p><h3 id="6-2-在图网络中的应用"><a href="#6-2-在图网络中的应用" class="headerlink" title="6.2 在图网络中的应用"></a>6.2 在图网络中的应用</h3><p>详见：<a href="https://www.jiqizhixin.com/articles/2019-07-19-3?from=synced&keyword=GAN">综述 | 生成对抗网络（GAN）在图网络中的应用</a></p><p>GraphGAN采用GAN网络中常见的对抗机制：生成器G尽可能的逼近Ptrue(V|Vc)以找到与Vc的相邻节点极其相似的节点来欺骗判别器D，而判别器D则会反过来检测给定的节点V是Vc的真实邻居还是由生成器生成的。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2019-08-13-021645.png" alt="image-20190813101644848"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.bilibili.com/video/av15999082?from=search&seid=7361319389662604746">什么是 GAN 生成对抗网络 (深度学习)? - 莫烦Python</a></li><li><a href="https://zhuanlan.zhihu.com/p/24767059">GAN学习指南：从原理入门到制作生成Demo</a></li><li><a href="https://www.jiqizhixin.com/articles/2019-03-19-12?from=synced&keyword=GAN">万字综述之生成对抗网络 (GAN)</a></li><li><a href="http://ir.ia.ac.cn/handle/173211/20218">生成式对抗网络GAN的研究进展与展望</a></li><li><a href="https://juejin.im/post/5d234eb16fb9a07f0870b9be#heading-9">必读的10篇关于GAN的论文</a></li><li><a href="https://www.cnblogs.com/fydeblog/p/9439024.html">GAN笔记——理论与实现</a></li></ol><h2 id="一些相关资料"><a href="#一些相关资料" class="headerlink" title="一些相关资料"></a>一些相关资料</h2><ol><li><a href="https://github.com/zhangqianhui/AdversarialNetsPapers">GAN论文汇总</a></li><li><a href="https://github.com/TwistedW/tensorflow-GANs">tensorflow-GANs</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650731540&idx=1&sn=193457603fe11b89f3d298ac1799b9fd&chksm=871b306ab06cb97c502af9552657b8e73f1f5286bc4cc71b021f64604fd53dae3f026bc9ac69&scene=21#wechat_redirect">机器之心GitHub项目：GAN完整理论推导与实现，Perfect！</a></li><li><a href="https://zhuanlan.zhihu.com/p/27549418">花式解释AutoEncoder与VAE</a></li><li><a href="https://zhuanlan.zhihu.com/p/34998569">变分自编码器VAE：原来是这么一回事 | 附开源代码</a></li><li><a href="http://www.sohu.com/a/164497415_610300">十个生成模型(GANs)的最佳案例和原理 | 代码+论文</a></li><li><a href="https://blog.csdn.net/z704630835/article/details/82017892">对抗生成网络学习（一）——GAN实现mnist手写数字生成(tensorflow实现)</a></li><li><a href="https://me.csdn.net/z704630835">全部梭哈迟早暴富 的CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tech</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
